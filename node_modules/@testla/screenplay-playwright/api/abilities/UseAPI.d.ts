import { APIRequestContext } from '@playwright/test';
import { Ability, Actor } from '@testla/screenplay';
import { RequestMethodType } from '../constants';
import { Response, ResponseBodyFormat, ResponseBodyType } from '../types';
export declare class UseAPI extends Ability {
    private requestContext;
    private constructor();
    /**
     * Get the request context object
     *
     * @returns {ApiRequestContext} requestContext the api request context
     */
    getRequestContext(): APIRequestContext;
    /**
     * Initialize this Ability by passing an already existing Playwright APIRequestContext object.
     *
     * @param {APIRequestContext} requestContext the Playwright APIRequestContext that will be used to send REST requests.
     * @returns {UseAPI} UseApi object
     */
    static using(requestContext: APIRequestContext): UseAPI;
    /**
     * Use this Ability as an Actor.
     *
     * @param {Actor} actor the actor object
     * @param {string} alias defined the alias to be used for the given ability
     * @returns {UseAPI} The ability to use the API as the actor
     */
    static as(actor: Actor, alias?: string): UseAPI;
    /**
     * Send a HTTP request (GET, POST, PATCH, PUT, HEAD or DELETE) to the specified url. Headers and data can also be sent.
     *
     * @param {RequestMethodType} method GET, POST, PATCH, PUT, HEAD or DELETE.
     * @param {string} url the full URL to the target.
     * @param {any} headers (optional) the headers object.
     * @param {ResponseBodyFormat} responseFormat (optional) specify the desired format the response body should be in.
     * @param {any} data (optional) the data to be sent.
     * @returns {Response} Promise<Response> a Response object consisting of status, body and headers.
     */
    sendRequest(method: RequestMethodType, url: string, headers?: any, responseFormat?: ResponseBodyFormat, data?: any): Promise<Response>;
    /**
     * Verify if the given status is equal or unequal to the given response's status.
     *
     * @param mode the result to check for.
     * @param response the response to check.
     * @param status the status to check.
     * @returns true if the status is equal/unequal as expected.
     */
    checkStatus(response: Response, status: number, mode: 'equal' | 'unequal'): Promise<boolean>;
    /**
     * Verify if the given body is equal or unequal to the given response's body.
     *
     * @param mode the result to check for.
     * @param response the response to check.
     * @param body the body to check.
     * @returns true if the body equal/unequal as expected.
     */
    checkBody(response: Response, body: ResponseBodyType, mode: 'equal' | 'unequal'): Promise<boolean>;
    /**
     * Verify if the given headers are included/excluded in the given response. (headers should be a subset of response.headers)
     *
     * @param mode the result to check for.
     * @param response the response to check.
     * @param headers the headers to check.
     * @returns true if the headers are is included/excluded as expected.
     */
    checkHeaders(response: Response, headers: {
        [key: string]: string | undefined;
    }, mode: 'included' | 'excluded'): Promise<boolean>;
    /**
     * Verify if the reponse (including receiving body) was received within a given duration or not.
     *
     * @param mode the result to check for.
     * @param response the response to check
     * @param duration expected duration (in milliseconds) not to be exceeded
     * @returns true if response was received within given duration, false otherwise
     */
    checkDuration(response: Response, duration: number, mode: 'lessOrEqual' | 'greater'): Promise<boolean>;
}
