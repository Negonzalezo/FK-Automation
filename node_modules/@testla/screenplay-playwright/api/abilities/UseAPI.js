"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UseAPI = void 0;
const test_1 = require("@playwright/test");
const screenplay_1 = require("@testla/screenplay");
const constants_1 = require("../constants");
class UseAPI extends screenplay_1.Ability {
    constructor(requestContext) {
        super();
        this.requestContext = requestContext;
    }
    /**
     * Get the request context object
     *
     * @returns {ApiRequestContext} requestContext the api request context
     */
    getRequestContext() {
        return this.requestContext;
    }
    /**
     * Initialize this Ability by passing an already existing Playwright APIRequestContext object.
     *
     * @param {APIRequestContext} requestContext the Playwright APIRequestContext that will be used to send REST requests.
     * @returns {UseAPI} UseApi object
     */
    static using(requestContext) {
        return new UseAPI(requestContext);
    }
    /**
     * Use this Ability as an Actor.
     *
     * @param {Actor} actor the actor object
     * @param {string} alias defined the alias to be used for the given ability
     * @returns {UseAPI} The ability to use the API as the actor
     */
    static as(actor, alias) {
        return actor.withAbilityTo(this, alias);
    }
    /**
     * Send a HTTP request (GET, POST, PATCH, PUT, HEAD or DELETE) to the specified url. Headers and data can also be sent.
     *
     * @param {RequestMethodType} method GET, POST, PATCH, PUT, HEAD or DELETE.
     * @param {string} url the full URL to the target.
     * @param {any} headers (optional) the headers object.
     * @param {ResponseBodyFormat} responseFormat (optional) specify the desired format the response body should be in.
     * @param {any} data (optional) the data to be sent.
     * @returns {Response} Promise<Response> a Response object consisting of status, body and headers.
     */
    sendRequest(method, url, headers, responseFormat, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = {
                headers,
                data,
            };
            // track time before sending request
            const startTime = Date.now();
            let res;
            switch (method) {
                case constants_1.RequestMethod.GET:
                    res = yield this.requestContext.get(url, options);
                    break;
                case constants_1.RequestMethod.POST:
                    res = yield this.requestContext.post(url, options);
                    break;
                case constants_1.RequestMethod.PATCH:
                    res = yield this.requestContext.patch(url, options);
                    break;
                case constants_1.RequestMethod.PUT:
                    res = yield this.requestContext.put(url, options);
                    break;
                case constants_1.RequestMethod.HEAD:
                    res = yield this.requestContext.head(url, options);
                    break;
                case constants_1.RequestMethod.DELETE:
                    res = yield this.requestContext.delete(url, options);
                    break;
                default:
                    throw new Error('Error: HTTP method not supported.');
            }
            let resBody;
            if (responseFormat === 'text') {
                resBody = yield res.text();
            }
            else if (responseFormat === 'buffer') {
                resBody = yield res.body();
            }
            else if (responseFormat === 'none') {
                resBody = null;
            }
            else {
                resBody = yield res.json();
            }
            // track time after receiving response
            const endTime = Date.now();
            return Promise.resolve({
                status: res.status(),
                body: resBody,
                headers: res.headers(),
                duration: endTime - startTime,
            });
        });
    }
    /**
     * Verify if the given status is equal or unequal to the given response's status.
     *
     * @param mode the result to check for.
     * @param response the response to check.
     * @param status the status to check.
     * @returns true if the status is equal/unequal as expected.
     */
    // eslint-disable-next-line class-methods-use-this
    checkStatus(response, status, mode) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, test_1.expect)(response.status === status).toBe(mode === 'equal');
            return Promise.resolve(true);
        });
    }
    /**
     * Verify if the given body is equal or unequal to the given response's body.
     *
     * @param mode the result to check for.
     * @param response the response to check.
     * @param body the body to check.
     * @returns true if the body equal/unequal as expected.
     */
    // eslint-disable-next-line class-methods-use-this
    checkBody(response, body, mode) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof response.body === 'string' && typeof body === 'string') {
                // response body is plain text -> can check for string equality
                (0, test_1.expect)(response.body === body).toBe(mode === 'equal');
                return Promise.resolve(true);
            }
            if (typeof response.body === 'object' && typeof body === 'object') {
                // check for buffer
                if (Buffer.isBuffer(response.body) && Buffer.isBuffer(body)) {
                    (0, test_1.expect)(response.body.equals(body)).toBe(mode === 'equal');
                    return Promise.resolve(true);
                }
                if (Buffer.isBuffer(response.body) || Buffer.isBuffer(body)) {
                    // response.body and body do not have same type -> bodies are unequal
                    (0, test_1.expect)(mode === 'unequal').toBe(true);
                    return Promise.resolve(true);
                }
                // response body is in json format OR null -> can check with JSON.stringify
                (0, test_1.expect)(JSON.stringify(response.body) === JSON.stringify(body)).toBe(mode === 'equal');
                return Promise.resolve(true);
            }
            // response.body and body do not have same type -> bodies are unequal
            (0, test_1.expect)(mode === 'unequal').toBe(true);
            return Promise.resolve(true);
        });
    }
    /**
     * Verify if the given headers are included/excluded in the given response. (headers should be a subset of response.headers)
     *
     * @param mode the result to check for.
     * @param response the response to check.
     * @param headers the headers to check.
     * @returns true if the headers are is included/excluded as expected.
     */
    // eslint-disable-next-line class-methods-use-this
    checkHeaders(response, headers, mode) {
        return __awaiter(this, void 0, void 0, function* () {
            const allResponseHeaderKeys = Object.keys(response.headers);
            (0, test_1.expect)(Object.entries(headers).every((header) => allResponseHeaderKeys.includes(header[0]) // lookup that every header key of headers is inside response.headers
                && (header[1] === undefined || response.headers[header[0]] === header[1]))).toBe(mode === 'included');
            return Promise.resolve(true);
        });
    }
    /**
     * Verify if the reponse (including receiving body) was received within a given duration or not.
     *
     * @param mode the result to check for.
     * @param response the response to check
     * @param duration expected duration (in milliseconds) not to be exceeded
     * @returns true if response was received within given duration, false otherwise
     */
    // eslint-disable-next-line class-methods-use-this
    checkDuration(response, duration, mode) {
        (0, test_1.expect)(response.duration <= duration).toBe(mode === 'lessOrEqual');
        return Promise.resolve(true);
    }
}
exports.UseAPI = UseAPI;
