"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Response = void 0;
const screenplay_1 = require("@testla/screenplay");
const UseAPI_1 = require("../abilities/UseAPI");
/**
 * Question Class. Verify certain aspects of an API Response.
 */
class Response extends screenplay_1.Question {
    constructor(checkMode) {
        super();
        this.checkMode = checkMode;
        // the response to check.
        this.response = {
            body: null,
            status: 0,
            headers: {},
            duration: 0,
        };
    }
    /**
     * Verify if the given status is equal to the given response's status.
     *
     * @param {Actor} actor the actor which is used
     * @return {boolean} the verification result true or false
     */
    answeredBy(actor) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.action.mode === 'status') {
                // if .is was called -> positive check, if .not was called -> negative check
                return Promise.resolve(yield UseAPI_1.UseAPI.as(actor, this.abilityAlias).checkStatus(this.response, this.action.payload.statusCode, this.checkMode === 'positive' ? 'equal' : 'unequal')); // if the ability method is not the expected result there will be an exception
            }
            if (this.action.mode === 'body') {
                // if .is was called -> positive check, if .not was called -> negative check
                return Promise.resolve(yield UseAPI_1.UseAPI.as(actor, this.abilityAlias).checkBody(this.response, this.action.payload.body, this.checkMode === 'positive' ? 'equal' : 'unequal')); // if the ability method is not the expected result there will be an exception
            }
            if (this.action.mode === 'header') {
                // if .is was called -> positive check, if .not was called -> negative check
                return Promise.resolve(yield UseAPI_1.UseAPI.as(actor, this.abilityAlias).checkHeaders(this.response, this.action.payload.headers, this.checkMode === 'positive' ? 'included' : 'excluded')); // if the ability method is not the expected result there will be an exception
            }
            if (this.action.mode === 'duration') {
                // if .is was called -> positive check, if .not was called -> negative check
                return Promise.resolve(yield UseAPI_1.UseAPI.as(actor, this.abilityAlias).checkDuration(this.response, this.action.payload.duration, this.checkMode === 'positive' ? 'lessOrEqual' : 'greater')); // if the ability method is not the expected result there will be an exception
            }
            throw new Error('Unknown mode for Response.answeredBy');
        });
    }
    /**
     * make the Question check for the positive.
     * @return {Response} the new Response instance
     */
    static get has() {
        return new Response('positive');
    }
    /**
     * make the Question check for the negative.
     * @return {Response} the new Response instance
     */
    static get hasNot() {
        return new Response('negative');
    }
    /**
     * Verify if the given status is equal to the given response's status.
     *
     * @param {ResponseType} response the response to check.
     * @param {number} statusCode the expected status code.
     * @return {Response} the Response instance
     */
    statusCode(response, statusCode) {
        this.response = response;
        this.addToCallStack({ caller: 'statusCode', calledWith: { response, statusCode } });
        this.action = { mode: 'status', payload: { statusCode } };
        return this;
    }
    /**
     * Verify if the given body is equal to the given response's body.
     *
     * @param {ResponseType} response the response to check.
     * @param {ResponseBodyType} body the expected body.
     * @return {Response} the Response instance
     */
    body(response, body) {
        this.response = response;
        this.addToCallStack({ caller: 'body', calledWith: { response, body } });
        this.action = { mode: 'body', payload: { body } };
        return this;
    }
    /**
     * Verify if the given headers are included in the given response.
     *
     * @param {ResponseType} response the response to check.
     * @param {Headers} headers the expected header.
     * @return {Response} the Response instance
     */
    headers(response, headers) {
        this.response = response;
        this.addToCallStack({ caller: 'headers', calledWith: { response, headers } });
        this.action = { mode: 'header', payload: { headers } };
        return this;
    }
    /**
     * Verify if the reponse (including receiving body) was received within a given duration.
     *
     * @param {ResponseType} response the response to check
     * @param {number} duration expected duration (in milliseconds) not to be exceeded
     * @return {Response} the Response instance
     */
    beenReceivedWithin(response, duration) {
        this.response = response;
        this.addToCallStack({ caller: 'beenReceivedWithin', calledWith: { response, duration } });
        this.action = { mode: 'duration', payload: { duration } };
        return this;
    }
}
exports.Response = Response;
