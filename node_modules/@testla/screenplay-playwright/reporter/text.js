"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const screenplay_1 = require("@testla/screenplay");
const fs_1 = require("fs");
const stream_1 = require("stream");
const FilterEvent_1 = require("../streams/FilterEvent");
const EventToTextTransformer_1 = require("../streams/EventToTextTransformer");
const ParseEvent_1 = require("../streams/ParseEvent");
const stream_2 = require("../utils/stream");
const constants_1 = require("../constants");
class TextReporter {
    constructor(config) {
        this.passed = [];
        this.flaky = [];
        this.failed = [];
        this.skipped = [];
        this.interrupted = [];
        this.outputFile = `${config.configDir}/${config.outputFile || 'screenplay-report.txt'}`;
    }
    putIntoBucket(testId, status) {
        switch (status) {
            case 'skipped':
                this.skipped.push(testId);
                break;
            case 'interrupted':
                this.interrupted.push(testId);
                break;
            case 'failed':
            case 'timedOut':
                if (!this.failed.some((entry) => entry === testId)) {
                    this.failed.push(testId);
                }
                break;
            case 'passed':
            default:
                if (this.failed.some((entry) => entry === testId)) {
                    this.failed = this.failed.filter((entry) => entry !== testId);
                    this.flaky.push(testId);
                }
                this.passed.push(testId);
        }
    }
    static getResultStatusIcon(status) {
        switch (status) {
            case 'failed':
                return constants_1.ICON.FAIL;
            case 'timedOut':
                return constants_1.ICON.FAIL;
            case 'interrupted':
                return constants_1.ICON.FAIL;
            case 'skipped':
                return constants_1.ICON.SKIP;
            case 'passed':
            default:
                return constants_1.ICON.PASS;
        }
    }
    static getTestId(test) {
        const paths = test.titlePath();
        return paths.filter((entry) => entry !== '').join(' > ');
    }
    write(msg) {
        if (this.outputFile) {
            (0, fs_1.appendFileSync)(this.outputFile, `${msg}\n`);
        }
    }
    onBegin() {
        if (this.outputFile && (0, fs_1.existsSync)(this.outputFile)) {
            (0, fs_1.rm)(this.outputFile, (err) => {
                if (err) {
                    throw (err);
                }
            });
        }
        process.env[screenplay_1.STRUCTURED_LOGS_ENVVAR_NAME] = 'true';
    }
    onTestEnd(test, result) {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line
            // @ts-ignore
            // eslint-disable-next-line
            this.write(`[${test._projectId.toUpperCase()}] ${TextReporter.getResultStatusIcon(result.status)} ${test.parent.title} › ${test.title} ${result.retry > 0 ? `[RETRY#${result.retry}] ` : ''}[${result.status.toUpperCase()} after ${TextReporter.printRuntime(result.duration)}]`);
            if (result.status !== 'skipped') {
                this.write('────────────────────────────────');
            }
            // eslint-disable-next-line no-await-in-loop
            const reportString = yield (0, stream_2.streamToString)(stream_1.Readable.from(result.stdout)
                .pipe(new FilterEvent_1.FilterEventStream())
                .pipe(new ParseEvent_1.ParseEventStream())
                .pipe(new EventToTextTransformer_1.TransformEventToTextStream()));
            this.write(reportString);
            this.putIntoBucket(TextReporter.getTestId(test), result.status);
        });
    }
    onEnd(result) {
        this.write('────────────────────────────────\n');
        this.write(`Finished the run: ${result.status.toUpperCase()} after ${TextReporter.printRuntime(result.duration)}\n`);
        if (this.failed.length) {
            this.write(`Failed: ${this.failed.length}`);
            this.failed.sort().forEach((failed) => this.write(`    - ${TextReporter.reformatFailedString(failed)}`));
        }
        if (this.skipped.length) {
            this.write(`Skipped: ${this.skipped.length}`);
        }
        if (this.flaky.length) {
            this.write(`Flaky: ${this.flaky.length}`);
        }
        if (this.interrupted.length) {
            this.write(`Interrupted: ${this.interrupted.length}`);
        }
        if (this.passed.length) {
            this.write(`Passed: ${this.passed.length}`);
        }
    }
    static printRuntime(time) {
        return `${(Math.round(time * 1000) / 1000000).toFixed(3)}s`;
    }
    static reformatFailedString(str) {
        const firstArrowReplaced = str.replace('>', '›');
        const parts = firstArrowReplaced.split('›');
        return `[${parts[0].trim().toUpperCase()}] ✗ ${parts[1].trim().replaceAll('>', '›')}`;
    }
    // eslint-disable-next-line class-methods-use-this
    printsToStdio() {
        return false;
    }
}
exports.default = TextReporter;
