"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransformEventToTextStream = void 0;
const screenplay_1 = require("@testla/screenplay");
const stream_1 = require("stream");
const constants_1 = require("../constants");
class TransformEventToTextStream extends stream_1.Transform {
    constructor() {
        super({
            objectMode: true,
        });
    }
    static getStatusText(status) {
        let badge = '';
        switch (status) {
            case screenplay_1.EXEC_STATUS.START:
                badge = 'EXEC';
                break;
            case screenplay_1.EXEC_STATUS.FAILED:
                badge = 'FAIL';
                break;
            case screenplay_1.EXEC_STATUS.SKIPPED:
                badge = 'SKIP';
                break;
            default:
                badge = 'DONE';
        }
        return badge;
    }
    static indent(level) {
        let indentation = ' ';
        for (let i = 0; i <= level * constants_1.BLANKS_PER_INDENTATION_LEVEL; i += 1) {
            indentation = ` ${indentation}`;
        }
        return indentation;
    }
    // eslint-disable-next-line no-underscore-dangle
    _transform(record, encoding, callback) {
        const msg = `${record.time}  [${TransformEventToTextStream.getStatusText(record.status)}]${TransformEventToTextStream.indent(record.wrapLevel)}${record.status !== screenplay_1.EXEC_STATUS.FAILED ? (record.activityType === screenplay_1.ACTIVITY_TYPE.QUESTION ? constants_1.ICON.PASS : constants_1.ICON.EXEC) : constants_1.ICON.FAIL} ${record.actor} ${record.activityAction} ${record.activityDetails}  (${record.filePath})`;
        this.push(msg);
        callback();
    }
}
exports.TransformEventToTextStream = TransformEventToTextStream;
