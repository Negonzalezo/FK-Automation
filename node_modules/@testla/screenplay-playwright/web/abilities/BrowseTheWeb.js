"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrowseTheWeb = void 0;
const screenplay_1 = require("@testla/screenplay");
/**
 * This class represents the actor's ability to use a Browser.
 */
class BrowseTheWeb extends screenplay_1.Ability {
    /**
     * Initialize this Ability by passing an already existing Playwright Page object.
     *
     * @param {Page} page the Playwright Page that will be used to browse.
     */
    constructor(page) {
        super();
        this.page = page;
    }
    /**
     * Initialize this Ability by passing an already existing Playwright Page object.
     *
     * @param {Page} page the Playwright Page that will be used to browse.
     * @return {BrowseTheWeb} Returns the ability to use a browser
     */
    static using(page) {
        return new BrowseTheWeb(page);
    }
    /**
     * Use this Ability as an Actor.
     *
     * @param {Actor} actor Actor is using this ability
     * @param {string} alias defined the alias to be used for the given ability
     * @return {BrowseTheWeb} The ability to use BrowseTheWeb as the actor
     */
    static as(actor, alias) {
        return actor.withAbilityTo(this, alias);
    }
    /**
     * Get the page object
     *
     * @returns {Page} the page object
     */
    getPage() {
        return this.page;
    }
    /**
     * Filters an existing locator based on sublocator and/or text
     * @param locator parent locator
     * @param subLocator sub locator to be checked for
     * @param text to be checked for
     * @returns filtered locator
     */
    static filterLocator(locator, subLocator, text) {
        return __awaiter(this, void 0, void 0, function* () {
            return locator.filter({ has: subLocator, hasText: text });
        });
    }
    /**
     * Calls a callback function based on the selectors type
     * @param selector The selector determining the further proceeding
     * @param proceedOptions Options to proceed based on types string, function or Locator
     * @returns Result of the proceeding function
     */
    static typeBasedProceeding(selector, proceedOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof selector === 'string') {
                return proceedOptions.str();
            }
            if (typeof selector === 'function') {
                return proceedOptions.fn();
            }
            return proceedOptions.loc();
        });
    }
    /**
     * Recursively resolves subSelectors starting with a Locator
     * @param param Object with all required parameters
     * @returns Promise<Locator> where Locator is a Playwright Locator
     */
    static subLocatorLookup({ base, locator, timeout, subSelector, state = 'visible', evaluateVisible = true, }) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            let resolvedLocator = locator;
            // wait for selector to become visible based on timeout options
            // in some cases it is desired to not have to wait for the visible state
            if (evaluateVisible) {
                yield resolvedLocator.waitFor({ timeout, state });
            }
            // check if we have subselectors
            // PROBLEM: if we use the Playwright locator directly, it does not consider the parent selector anymore -> can lead to problems regarding resolving to multiple elements
            if (subSelector) {
                resolvedLocator = yield BrowseTheWeb.typeBasedProceeding(subSelector[0], {
                    // if selector is a string, need to find it using locator.locator()
                    str: () => { var _a; return resolvedLocator.locator(subSelector[0], { hasText: (_a = subSelector[1]) === null || _a === void 0 ? void 0 : _a.hasText }); },
                    // in case of selector is a function we will propagate the current base (which i.e. is page) to it so that we can use build constructs like page.getByRole
                    fn: () => subSelector[0](base),
                    // if it is already a Playwright Locator use it directly.
                    loc: () => { var _a; return BrowseTheWeb.filterLocator(resolvedLocator, subSelector[0], (_a = subSelector[1]) === null || _a === void 0 ? void 0 : _a.hasText); },
                });
                // wait for sub selector to become visible based on timeout options
                // this is required so that functionality like click can be triggered on it
                yield resolvedLocator.waitFor({ timeout, state: 'visible' });
                // recursively lookup the next level if next subselector set
                if ((_a = subSelector[1]) === null || _a === void 0 ? void 0 : _a.subSelector) {
                    resolvedLocator = yield this.subLocatorLookup({
                        base, locator: resolvedLocator, timeout: (_b = subSelector[1]) === null || _b === void 0 ? void 0 : _b.timeout, subSelector: (_c = subSelector[1]) === null || _c === void 0 ? void 0 : _c.subSelector, state: (_d = subSelector[1]) === null || _d === void 0 ? void 0 : _d.state,
                    });
                }
            }
            return Promise.resolve(resolvedLocator);
        });
    }
    /**
     * Recursively resolves frames starting with Page Object
     * @param page Plawrights page object
     * @param frameTree An array of FrameLocators
     * @returns FrameLocator
     */
    static recursiveFrameLookup(page, frameTree) {
        let base = page;
        frameTree.forEach((node) => {
            base = base.frameLocator(node);
        });
        return base;
    }
    /**
     * Use the page mouse to hover over the specified element.
     *
     * @param {Selector} selector the selector of the element.
     * @param {SelectorOptions} options (optional) advanced selector lookup options.
     * @param {FrameSelector[]} [frameTree] - An array of frame selector(s).
     * @return {Locator} Returns resolved Locator(s) as per Playwright definition.
     */
    resolveSelectorToLocator(selector, options, frameTree) {
        return __awaiter(this, void 0, void 0, function* () {
            const { page } = this;
            // if frameTree has entries resocle FrameLocators before proceeding
            const base = frameTree === undefined || frameTree.length === 0
                ? page
                : BrowseTheWeb.recursiveFrameLookup(page, frameTree);
            const locator = yield BrowseTheWeb.typeBasedProceeding(selector, {
                // if selector is a string, need to find it using page.locator()
                str: () => base.locator(selector, { hasText: options === null || options === void 0 ? void 0 : options.hasText }),
                // in case of selector is a function we will propagate the current base (which i.e. is page) to it so that we can use build constructs like page.getByRole
                fn: () => selector(base),
                // if it is already a Playwright Locator use it directly.
                loc: () => BrowseTheWeb.filterLocator(selector, undefined, options === null || options === void 0 ? void 0 : options.hasText),
            });
            // pass the first level locator into sub locator lookup
            return BrowseTheWeb.subLocatorLookup({
                base, locator, timeout: options === null || options === void 0 ? void 0 : options.timeout, subSelector: options === null || options === void 0 ? void 0 : options.subSelector, state: options === null || options === void 0 ? void 0 : options.state, evaluateVisible: options === null || options === void 0 ? void 0 : options.evaluateVisible,
            });
        });
    }
}
exports.BrowseTheWeb = BrowseTheWeb;
