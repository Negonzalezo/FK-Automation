"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Element = void 0;
const test_1 = require("@playwright/test");
const BrowseTheWeb_1 = require("../abilities/BrowseTheWeb");
const FrameEnabledQuestion_1 = require("../templates/FrameEnabledQuestion");
/**
 * Question Class. Get a specified state for a selector like visible or enabled.
 */
class Element extends FrameEnabledQuestion_1.FrameEnabledQuestion {
    constructor(checkMode) {
        super();
        this.checkMode = checkMode;
        this.mode = 'visible';
        // the selector of the element to check.
        this.selector = '';
        // text or value to check.
        this.payload = '';
    }
    /**
     * Verifies if an element.
     *
     * @param {Actor} actor the actor
     * @return {boolean} if .is was called -> positive check, if .not was called -> negative check
     */
    answeredBy(actor) {
        return __awaiter(this, void 0, void 0, function* () {
            const { mode, selector, payload, checkMode, options, frameTree, abilityAlias, } = this;
            if (mode === 'visible') {
                const locator = yield BrowseTheWeb_1.BrowseTheWeb.as(actor, abilityAlias).resolveSelectorToLocator(selector, Object.assign(Object.assign({}, options), { state: checkMode === 'positive' ? 'visible' : 'hidden' }), frameTree);
                if (this.checkMode === 'positive') {
                    yield (0, test_1.expect)(locator).toBeVisible({ timeout: options === null || options === void 0 ? void 0 : options.timeout });
                }
                else {
                    yield (0, test_1.expect)(locator).toBeHidden({ timeout: options === null || options === void 0 ? void 0 : options.timeout });
                }
                return Promise.resolve(true); // if the ability method is not the expected result there will be an exception
            }
            if (mode === 'enabled') {
                const locator = yield BrowseTheWeb_1.BrowseTheWeb.as(actor, abilityAlias).resolveSelectorToLocator(selector, options, frameTree);
                if (this.checkMode === 'positive') {
                    yield (0, test_1.expect)(locator).toBeEnabled({ timeout: options === null || options === void 0 ? void 0 : options.timeout });
                }
                else {
                    yield (0, test_1.expect)(locator).toBeDisabled({ timeout: options === null || options === void 0 ? void 0 : options.timeout });
                }
                return Promise.resolve(true); // if the ability method is not the expected result there will be an exception
            }
            if (mode === 'text') {
                const locator = yield BrowseTheWeb_1.BrowseTheWeb.as(actor, abilityAlias).resolveSelectorToLocator(selector, options, frameTree);
                if (this.checkMode === 'positive') {
                    yield (0, test_1.expect)(locator).toHaveText(payload, { timeout: options === null || options === void 0 ? void 0 : options.timeout });
                }
                else {
                    yield (0, test_1.expect)(locator).not.toHaveText(payload, { timeout: options === null || options === void 0 ? void 0 : options.timeout });
                }
                return Promise.resolve(true); // if the ability method is not the expected result there will be an exception
            }
            if (mode === 'value') {
                const locator = yield BrowseTheWeb_1.BrowseTheWeb.as(actor, abilityAlias).resolveSelectorToLocator(selector, options, frameTree);
                if (this.checkMode === 'positive') {
                    yield (0, test_1.expect)(locator).toHaveValue(payload, { timeout: options === null || options === void 0 ? void 0 : options.timeout });
                }
                else {
                    yield (0, test_1.expect)(locator).not.toHaveValue(payload, { timeout: options === null || options === void 0 ? void 0 : options.timeout });
                }
                return Promise.resolve(true); // if the ability method is not the expected result there will be an exception
            }
            if (mode === 'checked') {
                const locator = yield BrowseTheWeb_1.BrowseTheWeb.as(actor, abilityAlias).resolveSelectorToLocator(selector, options, frameTree);
                if (this.checkMode === 'positive') {
                    yield (0, test_1.expect)(locator).toBeChecked({ timeout: options === null || options === void 0 ? void 0 : options.timeout });
                }
                else {
                    yield (0, test_1.expect)(locator).not.toBeChecked({ timeout: options === null || options === void 0 ? void 0 : options.timeout });
                }
                return Promise.resolve(true); // if the ability method is not the expected result there will be an exception
            }
            if (mode === 'count') {
                const locator = yield BrowseTheWeb_1.BrowseTheWeb.as(actor, abilityAlias).resolveSelectorToLocator(selector, Object.assign(Object.assign({}, options), { evaluateVisible: false }), frameTree);
                if (this.checkMode === 'positive') {
                    yield (0, test_1.expect)(locator).toHaveCount(payload, { timeout: options === null || options === void 0 ? void 0 : options.timeout });
                }
                else {
                    yield (0, test_1.expect)(locator).not.toHaveCount(payload, { timeout: options === null || options === void 0 ? void 0 : options.timeout });
                }
                return Promise.resolve(true); // if the ability method is not the expected result there will be an exception
            }
            if (mode === 'minCount') {
                if (checkMode === 'positive') {
                    yield BrowseTheWeb_1.BrowseTheWeb.as(actor, abilityAlias).resolveSelectorToLocator(`${selector} >> nth=${payload - 1}`, options, frameTree);
                }
                else {
                    yield BrowseTheWeb_1.BrowseTheWeb.as(actor, abilityAlias).resolveSelectorToLocator(`${selector} >> nth=${payload - 1}`, Object.assign(Object.assign({}, options), { state: 'hidden' }), frameTree);
                }
                return Promise.resolve(true);
                // if the ability method is not the expected result there will be an exception
            }
            throw new Error('Unknown mode: Element.answeredBy');
        });
    }
    /**
     * make the Question check for the positive.
     * @return {Element} new Element instance
     */
    static get toBe() {
        return new Element('positive');
    }
    /**
     * make the Question check for the negative.
     * @return {Element} new Element instance
     */
    static get notToBe() {
        return new Element('negative');
    }
    /**
     * make the Question check for the positive.
     * @return {Element} new Element instance
     */
    static get toHave() {
        return new Element('positive');
    }
    /**
     * make the Question check for the negative.
     * @return {Element} new Element instance
     */
    static get notToHave() {
        return new Element('negative');
    }
    /**
     * Verifies if an element is visible.
     *
     * @param {Selector} selector the selector
     * @param {SelectorOptions} options (optional) advanced selector lookup options.
     * @return {Element} this Element instance
     */
    visible(selector, options) {
        this.mode = 'visible';
        this.selector = selector;
        this.options = options;
        this.addToCallStack({ caller: 'visible', calledWith: { selector, options } });
        return this;
    }
    /**
     * Verifies if an element is enabled.
     *
     * @param {Selector} selector the selector
     * @param {SelectorOptions} options (optional) advanced selector lookup options.
     * @return {Element} this Element instance
     */
    enabled(selector, options) {
        this.mode = 'enabled';
        this.selector = selector;
        this.options = options;
        this.addToCallStack({ caller: 'enabled', calledWith: { selector, options } });
        return this;
    }
    /**
     * Verifies if an element has the given text.
     *
     * @param selector the selector.
     * @param text the text to check.
     * @param options (optional) advanced selector lookup options.
     */
    text(selector, text, options) {
        this.mode = 'text';
        this.selector = selector;
        this.payload = text;
        this.options = options;
        this.addToCallStack({ caller: 'text', calledWith: { selector, text, options } });
        return this;
    }
    /**
     * Verifies if an element has the given value.
     *
     * @param selector the selector.
     * @param value the value to check.
     * @param options (optional) advanced selector lookup options.
     */
    value(selector, value, options) {
        this.mode = 'value';
        this.selector = selector;
        this.payload = value;
        this.options = options;
        this.addToCallStack({ caller: 'value', calledWith: { selector, value, options } });
        return this;
    }
    /**
     * Verifies if an element has a minimum count.
     *
     * @param {Selector} selector the selector
     * @param {number} minimumCount the minimum count.
     * @param {SelectorOptions} options (optional) advanced selector lookup options.
     * @return {Element} this Element instance
     */
    minCount(selector, minimumCount, options) {
        this.payload = minimumCount;
        this.mode = 'minCount';
        this.selector = selector;
        this.options = options;
        this.addToCallStack({ caller: 'minCount', calledWith: { selector, minimumCount, options } });
        return this;
    }
    /**
     * Verifies if an element has a desired count.
     *
     * @param {Selector} selector the selector
     * @param {number} desiredCount the desired count.
     * @param {SelectorOptions} options (optional) advanced selector lookup options.
     * @return {Element} this Element instance
     */
    count(selector, desiredCount, options) {
        this.payload = desiredCount;
        this.selector = selector;
        this.mode = 'count';
        this.options = options;
        this.addToCallStack({ caller: 'count', calledWith: { selector, desiredCount, options } });
        return this;
    }
    /**
     * Verifies if an element is checked.
     *
     * @param {Selector} selector the selector
     * @param {SelectorOptions} options (optional) advanced selector lookup options.
     * @return {Element} this Element instance
     */
    checked(selector, options) {
        this.selector = selector;
        this.mode = 'checked';
        this.options = options;
        this.addToCallStack({ caller: 'checked', calledWith: { selector, options } });
        return this;
    }
}
exports.Element = Element;
